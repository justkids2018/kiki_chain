# 新功能开发指南（基于登录功能逐步映射）

目的：
- 提供一份可被AI或开发者直接按照步骤执行的新功能开发指南。
- 按照登录业务的实现细节，把每一步的文件、目录、代码逻辑、接口调用、校验与测试点列清楚，确保新功能在 DDD 架构与团队规范下可快速落地。

前提约束（必须遵守）
- 业务逻辑遵循 DDD 架构。
- API 请求必须统一使用 `RequestManager`。
- **错误处理必须使用统一异常系统：`ApiResponseException` 和 `ApiResponseHandler`**。
- UI 层的 Controller 必须使用 GetX，并放在当前模块目录下单独的 `contro---

## 9. 统一异常系统使用指南

### 核心原则
所有新功能必须使用统一异常系统：`ApiResponseException` + `ApiResponseHandler`，不再使用 NetworkException、AppException 等其他异常类型。

### 后端响应格式
标准的后端响应格式：
```json
{
  "success": true/false,
  "data": {...},           // 成功时的数据
  "message": "错误信息",    // 失败时的具体错误描述
  "errorcode": 200         // 错误码
}
```

### Repository 层标准实现
```dart
Future<SomeEntity> someMethod(SomeParams params) async {
  try {
    final response = await _requestManager.post<Map<String, dynamic>>(
      ApiEndpoints.someEndpoint,
      data: params.toJson(),
    );
    
    // 使用 ApiResponseHandler 自动处理后端响应
    final data = ApiResponseHandler.handle<Map<String, dynamic>>(response);
    return SomeEntity.fromJson(data);
    
  } on ApiResponseException {
    // API响应异常直接重新抛出（包含后端错误信息）
    rethrow;
  } catch (e) {
    // 其他异常转换为 ApiResponseException
    throw ApiResponseHandler.createException(e);
  }
}
```

### Controller 层标准实现
```dart
Future<void> someAction() async {
  try {
    isLoading.value = true;
    final result = await repository.someMethod(params);
    // 处理成功逻辑
    EasyLoading.showSuccess('操作成功');
    
  } on ApiResponseException catch (e) {
    // 处理所有异常（API响应、网络错误、认证错误等）
    String errorMessage = e.message;
    
    // 特殊处理需要重新认证的情况
    if (e.needsReauth) {
      errorMessage = '登录已过期，请重新登录';
      // 执行重新认证逻辑
    }
    
    EasyLoading.showError(errorMessage); // 显示后端返回的具体错误信息
    
  } catch (e) {
    // 处理其他未知异常
    EasyLoading.showError('操作失败，请重试');
  } finally {
    isLoading.value = false;
  }
}
```

### 异常处理优势
1. **自动提取后端错误信息**：`ApiResponseException.fromResponse()` 自动提取 `message` 字段，用户看到具体错误（如"师生关系已存在"）
2. **智能错误分类**：
   - `e.isApiResponse`：区分后端业务错误 vs 网络系统错误
   - `e.needsReauth`：自动判断是否需要重新认证
   - `e.isRetryable`：自动判断是否可重试
3. **统一性**：整个应用只使用一个异常类型，代码更简洁一致
4. **类型安全**：编译时类型检查，避免异常处理遗漏

### 详细参考文档
完整的统一异常系统迁移指南和使用示例，请参考：
- `doc/framework/exception_system_migration.md`

---

完成说明：
- 将该文档作为团队新功能开发的"模板/规范/执行脚本"保存于 `doc/framework/新功能开发指南标准_20250916.md`。
- 任何新功能均应根据本指南逐步执行，AI 可根据本指南生成相应的代码骨架与实现。
- **重要**：所有新功能必须使用统一异常系统，确保错误处理的一致性和用户体验。

如需，我可以：
- 把其中的伪代码直接生成到代码文件中（创建实体、Repository、Controller、Page 的骨架）
- 为登录功能生成更详细的校验/错误码映射表
- 为常见场景（分页、文件上传）写单独的实现模板。
- 所有实体对象放在 `lib/domain/entities/`。
- 新功能的 Repository 放在 `data/repositories/`。
- 所有请求路径统一在 `ApiEndpoints` 中定义并引用。
- 全局颜色在 `AppColors` 中管理。
- 路由初始化在 `AppRoutes` 中，路由 path 在 `AppConstants`。
- 业务代码开发在 presentation/pages/ 目录下，新业务可在该目录下创建独立目录

文档结构：
1. 需求到实现的映射（以登录为模板）
2. 目录与文件清单（骨架）
3. 逐步代码逻辑提示（每一步都可生成代码）
4. 接口与 API 示例（RequestManager 使用示例）
5. 校验/边界情况
6. 单元/集成测试建议
7. PR 检查清单
8. 示例：从零到一实现“重置密码”功能（演示如何复用登录模板）

---

## 1. 需求到实现的映射（以登录为模板）

登录功能拆解（每一步都应映射到相应文件与职责）：
1. UI 层：`presentation/pages/login_page.dart`（表单、错误展示、loading 状态、导航）
2. Controller：`presentation/controllers/auth_controller.dart`（表单校验、本地状态、调用 Repository）
3. Repository：`data/repositories/auth_repository.dart`（封装 RequestManager 调用，返回实体/错误）
4. Entity：`data/domain/entities/user.dart`（用户实体定义）
5. API 定义：`lib/config/api_endpoints.dart`（定义登录 path）
6. RequestManager：统一发送请求，处理 token、错误转换、网络重试策略
7. 路由：`lib/app_routes.dart` + `lib/app_constants.dart`（添加登录页面路由）
8. 全局样式：使用 `AppColors` 中定义的颜色

每一个新功能应复制以上责任边界，并替换为对应的业务名。

## 2. 目录与文件清单（骨架）

以 `feature_x` 为例，新功能应该创建如下结构：

- lib/
  - presentation/
    - pages/
      - feature_x_page.dart
    - controllers/
      - feature_x_controller.dart
  - data/
    - domain/
      - entities/
        - feature_x_entity.dart
    - repositories/
      - feature_x_repository.dart
  - config/
    - api_endpoints.dart (已存在，新增 path 常量)
  - ...

## 3. 逐步代码逻辑提示（一步一步对应登录实现）

以下每一步给出：目的 -> 文件 -> 核心代码提示（伪代码） -> 返回值/错误处理

步骤 0：准备
- 目的：确认 API path，实体字段，UI 字段。
- 操作：在 `ApiEndpoints` 中新增 `featureX` path；在 `data/domain/entities/` 新建实体草稿。

步骤 1：创建实体
- 文件：`data/domain/entities/feature_x_entity.dart`
- 伪代码：
  class FeatureXEntity {
    final String id;
    final String name;
    // ...fromJson / toJson
  }
- 关注点：字段校验、nullable vs non-nullable

步骤 2：实现 Repository
- 文件：`data/repositories/feature_x_repository.dart`
- 目的：封装 RequestManager 调用，返回 Entity 或抛出统一异常
- **必须使用统一异常系统**：
```dart
class FeatureXRepository {
  final RequestManager _requestManager;
  FeatureXRepository(this._requestManager);

  Future<FeatureXEntity> createFeatureX(CreateFeatureXParams params) async {
    try {
      final response = await _requestManager.post<Map<String, dynamic>>(
        ApiEndpoints.featureXCreate,
        data: params.toJson(),
      );
      
      // 使用 ApiResponseHandler 自动处理后端响应
      final data = ApiResponseHandler.handle<Map<String, dynamic>>(response);
      return FeatureXEntity.fromJson(data);
      
    } on ApiResponseException {
      // API响应异常直接重新抛出（包含后端错误信息）
      rethrow;
    } catch (e) {
      // 其他异常转换为 ApiResponseException
      throw ApiResponseHandler.createException(e);
    }
  }
}
```
- 错误处理：
  - **后端错误**：使用 `ApiResponseException.fromResponse()` 自动提取 `message` 字段
  - **网络错误**：使用 `ApiResponseHandler.createException()` 统一转换
  - **成功响应**：使用 `ApiResponseHandler.handle<T>()` 自动提取 `data` 字段

步骤 3：实现 Controller（Getx）
- 文件：`presentation/controllers/feature_x_controller.dart`
- 目的：持有表单状态、loading、错误信息；调用 Repository；路由导航
- 伪代码：
  class FeatureXController extends GetxController {
    final FeatureXRepository repo;
    var isLoading = false.obs;
    var errorMsg = ''.obs;

    final formKey = GlobalKey<FormState>();
    final nameController = TextEditingController();

    FeatureXController(this.repo);

    Future<void> submit() async {
      if (!formKey.currentState!.validate()) return;
      isLoading.value = true;
      try {
        final result = await repo.createFeatureX(CreateFeatureXParams(name: nameController.text));
        // 成功：导航或提示
        EasyLoading.showSuccess('操作成功');
        
      } on ApiResponseException catch (e) {
        // 处理所有异常（API响应、网络错误、认证错误等）
        String errorMessage = e.message;
        
        // 特殊处理需要重新认证的情况
        if (e.needsReauth) {
          errorMessage = '登录已过期，请重新登录';
          // 可以在这里执行重新认证逻辑
        }
        
        EasyLoading.showError(errorMessage); // 显示后端返回的具体错误信息
        errorMsg.value = errorMessage;
        
      } catch (e) {
        // 处理其他未知异常
        const message = '操作失败，请重试';
        EasyLoading.showError(message);
        errorMsg.value = message;
      } finally {
        isLoading.value = false;
      }
    }
  }
- 关注点：取消订阅、资源释放（onClose 清理 controllers）

步骤 4：实现 UI Page
- 文件：`presentation/pages/feature_x_page.dart`
- 目的：表单 UI，使用 controller 中的 observable 状态
- 伪代码：
  class FeatureXPage extends StatelessWidget {
    final controller = Get.put(FeatureXController(Get.find()));
    Widget build(...) {
      return Scaffold(
        body: Form(...)
        // TextFormField(controller: controller.nameController,...)
        // Obx显示loading/error
      );
    }
  }
- 关注点：保持与登录页面一致的 UX 结构（按钮样式、表单校验）

步骤 5：路由与常量
- 在 `AppConstants` 中添加 path: `/feature_x`
- 在 `AppRoutes` 初始化中注册该路由指向 `FeatureXPage`

步骤 6：样式与颜色
- 如果需要新颜色，先在 `AppColors` 中添加常量；UI 使用 `AppColors.primary` 而非硬编码色值

步骤 7：单元与集成测试
- Controller：测试 submit 成功/失败，mock Repository 返回
- Repository：对 RequestManager 进行 mock，测试不同响应码的行为
- UI：Widget test 验证表单校验和状态展示

## 4. 接口与 API 示例（RequestManager + 统一异常系统）

### 标准的 Repository 实现模式：

```dart
Future<FeatureXEntity> createFeatureX(CreateFeatureXParams params) async {
  try {
    final response = await _requestManager.post<Map<String, dynamic>>(
      ApiEndpoints.featureXCreate,
      data: params.toJson(),
    );
    
    // 使用 ApiResponseHandler 自动处理后端响应
    final data = ApiResponseHandler.handle<Map<String, dynamic>>(response);
    return FeatureXEntity.fromJson(data);
    
  } on ApiResponseException {
    // API响应异常直接重新抛出（包含后端错误信息）
    rethrow;
  } catch (e) {
    // 其他异常转换为 ApiResponseException
    throw ApiResponseHandler.createException(e);
  }
}
```

### 后端响应格式处理：

后端返回格式：`{success: true/false, data: {...}, message: "...", errorcode: 200}`

- **成功时**：`ApiResponseHandler.handle<T>()` 自动提取 `data` 字段
- **失败时**：`ApiResponseException.fromResponse()` 自动提取 `message` 字段
- **网络错误**：`ApiResponseHandler.createException()` 统一转换

### 推荐封装策略：
- 在 Repository 层使用 `ApiResponseHandler` 处理响应到实体的转换
- 在 Controller 层捕获 `ApiResponseException` 并显示具体错误信息
- 所有异常统一使用 `ApiResponseException`，不再使用其他异常类型

## 5. 校验 / 边界情况

- 输入校验（前端）：必填、长度、格式（手机号/邮箱正则）
- **后端校验错误**：使用 `ApiResponseException` 自动提取并显示后端返回的 `message` 字段（如"师生关系已存在"）
- **网络异常**：统一转换为 `ApiResponseException`，根据 `isRetryable` 属性决定是否支持重试
- **认证异常**：根据 `needsReauth` 属性自动判断是否需要重新登录
- 并发/去抖：提交按钮防重复点击（基于isLoading）
- 超时策略：RequestManager 默认 15s，可在特殊接口覆盖
- **异常分类处理**：
  - `e.isApiResponse = true`：后端业务错误，显示具体 message
  - `e.isApiResponse = false`：网络/系统错误，显示通用提示
  - `e.needsReauth = true`：需要重新认证，引导用户登录
  - `e.isRetryable = true`：可重试错误，提供重试选项

## 6. 单元/集成测试建议

- Controller 测试：
  - 表单验证失败不应调用 Repository
  - 成功路径应触发导航或状态更新
  - 异常路径应设置 `errorMsg` 并停止 loading

- Repository 测试：
  - 模拟不同的 HTTP 响应码，验证异常包装

- Widget 测试：
  - 表单校验提示
  - 当 `isLoading` 时禁用按钮并显示 loading

## 7. PR 检查清单

- [ ] 是否遵循 DDD 目录约束
- [ ] 是否使用 `RequestManager` 而非直接 http client
- [ ] **是否使用统一异常系统（`ApiResponseException` + `ApiResponseHandler`）**
- [ ] **Repository 层是否正确使用 `ApiResponseHandler.handle<T>()` 处理响应**
- [ ] **Controller 层是否正确捕获 `ApiResponseException` 并显示具体错误信息**
- [ ] Controller 是否使用 GetX，并放在模块的 `controllers/`
- [ ] 实体是否放在 `data/domain/entities/`
- [ ] Repository 是否在 `data/repositories/`
- [ ] 所有 API path 是否在 `ApiEndpoints` 中定义
- [ ] 颜色是否来自 `AppColors`
- [ ] 路由是否在 `AppRoutes` 和 `AppConstants` 中注册
- [ ] 是否添加了单元/集成测试
- [ ] 文档是否在 `doc/` 中说明了变更点

## 8. 示例：实现“重置密码”功能（从登录模板复制）

1. ApiEndpoints 中添加：
```dart
static const resetPassword = '/auth/reset-password';
```

2. 实体：`data/domain/entities/reset_password_response.dart`
3. Repository：`data/repositories/auth_repository.dart` 添加方法：
```dart
Future<void> resetPassword(String phoneOrEmail) async {
  try {
    final response = await _requestManager.post<Map<String, dynamic>>(
      ApiEndpoints.resetPassword, 
      data: {"account": phoneOrEmail}
    );
    
    // 使用 ApiResponseHandler 处理响应
    ApiResponseHandler.handle<Map<String, dynamic>>(response);
    
  } on ApiResponseException {
    // API响应异常直接重新抛出
    rethrow;
  } catch (e) {
    // 其他异常转换为 ApiResponseException
    throw ApiResponseHandler.createException(e);
  }
}
```

4. Controller：`presentation/controllers/auth_controller.dart` 添加 `resetPasswordController`、方法 `resetPassword()`，复用表单逻辑和 loading/error 处理
5. Page：`presentation/pages/reset_password_page.dart`，复用 login_page 的样式和结构
6. 路由：`AppConstants` + `AppRoutes` 注册
7. 测试：参考步骤 6

---

完成说明：
- 将该文档作为团队新功能开发的“模板/规范/执行脚本”保存于 `doc/task/新功能开发指南.md`。
- 任何新功能均应根据本指南逐步执行，AI 可根据本指南生成相应的代码骨架与实现。

如需，我可以：
- 把其中的伪代码直接生成到代码文件中（创建实体、Repository、Controller、Page 的骨架）
- 为登录功能生成更详细的校验/错误码映射表
- 为常见场景（分页、文件上传）写单独的实现模板
