# å¼€å‘æ–¹æ³•å¼•ç”¨æ–‡æ¡£

## 1. å¼€å‘æµç¨‹æŒ‡å—

### 1.1 åŸºäºç™»å½•åŠŸèƒ½çš„å¼€å‘æ–¹æ³•è®º

æœ¬æ–‡æ¡£åŸºäºå·²å®ç°çš„ç™»å½•åŠŸèƒ½ï¼Œæ€»ç»“å‡ºä¸€å¥—å¯å¤ç”¨çš„å¼€å‘æ–¹æ³•å’Œå…³é”®æ–¹æ³•å¼•ç”¨ã€‚

### 1.2 DDDå¼€å‘æ­¥éª¤

```
1. é¢†åŸŸå»ºæ¨¡ â†’ 2. å®šä¹‰ä»“å‚¨æ¥å£ â†’ 3. å®ç°ç”¨ä¾‹ â†’ 4. åˆ›å»ºæ§åˆ¶å™¨ â†’ 5. é…ç½®è·¯ç”± â†’ 6. é›†æˆæµ‹è¯•
```

## 2. å…³é”®æ–¹æ³•å¼•ç”¨æ¸…å•

### 2.1 é¢†åŸŸå±‚å…³é”®æ–¹æ³•

#### å®ä½“åˆ›å»ºæ–¹æ³•
```rust
// æ–‡ä»¶: src/domain/entities.rs
// æ–¹æ³•: User::new() - åˆ›å»ºæ–°å®ä½“
pub fn new(
    uid: String,
    name: String, 
    email: String,
    phone: String,
    pwd: String,
    role_id: i32,
) -> Self {
    Self {
        id: Uuid::new_v4(),
        uid,
        name,
        email,
        phone,
        pwd,
        created_at: Utc::now(),
        updated_at: Utc::now(),
        role_id,
    }
}

// æ–¹æ³•: User::reconstruct() - ä»æ•°æ®åº“é‡æ„å®ä½“
pub fn reconstruct(/* æ‰€æœ‰å­—æ®µ */) -> Self

// æ–¹æ³•: User::update_timestamp() - æ›´æ–°æ—¶é—´æˆ³
pub fn update_timestamp(&mut self) {
    self.updated_at = Utc::now();
}
```

#### ä»“å‚¨æ¥å£å®šä¹‰æ–¹æ³•
```rust
// æ–‡ä»¶: src/domain/repositories.rs
// å®šä¹‰ä»“å‚¨æ¥å£çš„æ ‡å‡†æ¨¡å¼

#[async_trait]
pub trait UserRepository: Send + Sync {
    // æŸ¥è¯¢æ–¹æ³•
    async fn find_by_phone(&self, phone: &str) -> Result<Option<User>>;
    async fn find_by_email(&self, email: &str) -> Result<Option<User>>;
    async fn find_by_id(&self, id: &Uuid) -> Result<Option<User>>;
    
    // æŒä¹…åŒ–æ–¹æ³•
    async fn save(&self, user: &User) -> Result<()>;
    async fn delete(&self, id: &Uuid) -> Result<()>;
}
```

### 2.2 åº”ç”¨å±‚å…³é”®æ–¹æ³•

#### ç”¨ä¾‹å®ç°æ¨¡å¼
```rust
// æ–‡ä»¶: src/application/use_cases/auth/login_user.rs
// æ ‡å‡†ç”¨ä¾‹ç»“æ„å’Œæ–¹æ³•

pub struct LoginUserUseCase {
    user_repository: Arc<dyn UserRepository>,
}

impl LoginUserUseCase {
    // æ„é€ æ–¹æ³• - ä¾èµ–æ³¨å…¥
    pub fn new(user_repository: Arc<dyn UserRepository>) -> Self {
        Self { user_repository }
    }
    
    // ä¸»æ‰§è¡Œæ–¹æ³• - ä¸šåŠ¡æµç¨‹ç¼–æ’
    pub async fn execute(&self, command: LoginUserCommand) -> Result<LoginUserResponse> {
        // 1. è¾“å…¥éªŒè¯
        self.validate_command(&command)?;
        
        // 2. ä¸šåŠ¡é€»è¾‘æ‰§è¡Œ
        let user = self.find_user(&command.identifier).await?;
        self.verify_password(&user, &command.password)?;
        
        // 3. å‰¯ä½œç”¨å¤„ç†
        let mut updated_user = user.clone();
        updated_user.update_timestamp();
        self.user_repository.save(&updated_user).await?;
        
        // 4. å·¥å…·åº“è°ƒç”¨
        let token = JwtUtils::generate_token(&updated_user)?;
        
        // 5. å“åº”æ„å»º
        Ok(LoginUserResponse { /* å­—æ®µæ˜ å°„ */ })
    }
    
    // ç§æœ‰è¾…åŠ©æ–¹æ³• - è¾“å…¥éªŒè¯
    fn validate_command(&self, command: &LoginUserCommand) -> Result<()> {
        if command.identifier.trim().is_empty() {
            return Err(DomainError::Validation("æ‰‹æœºå·æˆ–é‚®ç®±ä¸èƒ½ä¸ºç©º".to_string()));
        }
        if command.password.trim().is_empty() {
            return Err(DomainError::Validation("å¯†ç ä¸èƒ½ä¸ºç©º".to_string()));
        }
        Ok(())
    }
    
    // ç§æœ‰è¾…åŠ©æ–¹æ³• - ä¸šåŠ¡é€»è¾‘
    async fn find_user(&self, identifier: &str) -> Result<User> {
        if let Some(user) = self.user_repository.find_by_phone(identifier).await? {
            return Ok(user);
        }
        Err(DomainError::Authentication("ç”¨æˆ·å/é‚®ç®±æˆ–å¯†ç é”™è¯¯".to_string()))
    }
    
    // ç§æœ‰è¾…åŠ©æ–¹æ³• - å¯†ç éªŒè¯
    fn verify_password(&self, user: &User, password: &str) -> Result<()> {
        Logger::info(&format!("ğŸ” [å¯†ç éªŒè¯] å¼€å§‹éªŒè¯ç”¨æˆ· {} çš„å¯†ç ", user.uid()));
        
        let is_valid = ToolUtils::verify_password(password, user.pwd())?;
        Logger::info(&format!("ğŸ” [å¯†ç éªŒè¯] éªŒè¯ç»“æœ: {}", is_valid));
        
        if !is_valid {
            Logger::warn(&format!("âŒ [å¯†ç éªŒè¯] ç”¨æˆ· {} å¯†ç éªŒè¯å¤±è´¥", user.uid()));
            return Err(DomainError::Authentication("ç”¨æˆ·å/é‚®ç®±æˆ–å¯†ç é”™è¯¯".to_string()));
        }
        
        Logger::info(&format!("âœ… [å¯†ç éªŒè¯] ç”¨æˆ· {} å¯†ç éªŒè¯æˆåŠŸ", user.uid()));
        Ok(())
    }
}
```

#### å‘½ä»¤å’Œå“åº”DTOæ¨¡å¼
```rust
// å‘½ä»¤æ¨¡å¼ - è¾“å…¥å°è£…
#[derive(Debug, Deserialize)]
pub struct LoginUserCommand {
    pub identifier: String,  // ä¸šåŠ¡æ ‡è¯†ç¬¦
    pub password: String,    // æ•æ„Ÿä¿¡æ¯
}

// å“åº”æ¨¡å¼ - è¾“å‡ºå°è£…
#[derive(Debug, Serialize)]
pub struct LoginUserResponse {
    pub user_id: String,     // ä¸šåŠ¡ID
    pub name: String,        // æ˜¾ç¤ºä¿¡æ¯
    pub email: String,       // è”ç³»ä¿¡æ¯
    pub token: String,       // ä¼šè¯ä¿¡æ¯
    pub message: String,     // çŠ¶æ€æ¶ˆæ¯
    pub phone: String,       // è”ç³»ä¿¡æ¯
    pub role_id: i32,        // æƒé™ä¿¡æ¯
}
```

### 2.3 è¡¨ç°å±‚å…³é”®æ–¹æ³•

#### æ§åˆ¶å™¨å®ç°æ¨¡å¼
```rust
// æ–‡ä»¶: src/presentation/http/auth_controller.rs
// æ§åˆ¶å™¨æ ‡å‡†ç»“æ„å’Œæ–¹æ³•

pub struct AuthController {
    register_use_case: Arc<RegisterUserUseCase>,
    login_use_case: Arc<LoginUserUseCase>,
}

impl AuthController {
    // æ„é€ æ–¹æ³• - ç”¨ä¾‹æ³¨å…¥
    pub fn new(
        register_use_case: Arc<RegisterUserUseCase>,
        login_use_case: Arc<LoginUserUseCase>,
    ) -> Self {
        Self {
            register_use_case,
            login_use_case,
        }
    }
    
    // HTTPå¤„ç†æ–¹æ³• - JSONè½¬æ¢
    pub async fn login(&self, request: Value) -> Result<Value> {
        // 1. è¯·æ±‚ååºåˆ—åŒ–
        let command: LoginUserCommand = serde_json::from_value(request)
            .map_err(|e| DomainError::Validation(format!("è¯·æ±‚å‚æ•°è§£æå¤±è´¥: {}", e)))?;
        
        // 2. ç”¨ä¾‹è°ƒç”¨
        let response = self.login_use_case.execute(command).await?;
        
        // 3. å“åº”åºåˆ—åŒ–
        let response_value = Logger::to_json_value(response)
            .map_err(|e| DomainError::Infrastructure(format!("å“åº”åºåˆ—åŒ–å¤±è´¥: {}", e)))?;
        
        Ok(response_value)
    }
}
```

#### è·¯ç”±é…ç½®æ–¹æ³•
```rust
// æ–‡ä»¶: src/app/routes/auth.rs
// è·¯ç”±é…ç½®æ ‡å‡†æ¨¡å¼

pub fn create_auth_routes(app_state: AppState) -> Router {
    Logger::info("ğŸ” [è®¤è¯æ¨¡å—] åˆå§‹åŒ–è®¤è¯è·¯ç”±");
    
    Router::new()
        .route("/api/auth/login", post(login))
        .route("/api/auth/register", post(register))
        .route("/api/auth/verify", get(verify))
        .with_state(app_state)
}

// HTTPå¤„ç†å™¨æ–¹æ³•
#[instrument(name = "login")]
async fn login(
    State(app_state): State<AppState>,
    Json(request): Json<Value>
) -> Result<Json<Value>, (StatusCode, Json<Value>)> {
    Logger::info("ğŸ” [ç”¨æˆ·ç™»å½•] å¼€å§‹ç™»å½•æµç¨‹");
    
    match app_state.auth_controller.login(request).await {
        Ok(response) => {
            Logger::info("âœ… [ç”¨æˆ·ç™»å½•] ç™»å½•æˆåŠŸ");
            Ok(Json(response))
        },
        Err(e) => {
            Logger::warn(&format!("ğŸš« [ç”¨æˆ·ç™»å½•] ç™»å½•å¤±è´¥: {:?}", e));
            Err((StatusCode::UNAUTHORIZED, Json(json!({
                "error": "ç”¨æˆ·æˆ–å¯†ç é”™è¯¯"
            }))))
        }
    }
}
```

### 2.4 åŸºç¡€è®¾æ–½å±‚å…³é”®æ–¹æ³•

#### ä»“å‚¨å®ç°æ¨¡å¼
```rust
// æ–‡ä»¶: src/infrastructure/persistence/postgres_user_repository.rs
// PostgreSQLä»“å‚¨å®ç°æ ‡å‡†æ¨¡å¼

pub struct PostgresUserRepository {
    pool: PgPool,
}

impl PostgresUserRepository {
    // æ„é€ æ–¹æ³•
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl UserRepository for PostgresUserRepository {
    // æŸ¥è¯¢æ–¹æ³•å®ç°
    async fn find_by_phone(&self, phone: &str) -> Result<Option<User>> {
        let query = "
            SELECT id, uid, name, email, phone, pwd, created_at, updated_at, role_id 
            FROM users 
            WHERE phone = $1
        ";
        
        match sqlx::query_as::<_, UserRow>(query)
            .bind(phone)
            .fetch_optional(&self.pool)
            .await
        {
            Ok(Some(row)) => {
                let user = User::reconstruct(
                    row.id, row.uid, row.name, row.email, 
                    row.phone, row.pwd, row.created_at, 
                    row.updated_at, row.role_id,
                );
                Ok(Some(user))
            },
            Ok(None) => Ok(None),
            Err(e) => Err(DomainError::Infrastructure(format!("æ•°æ®åº“æŸ¥è¯¢å¤±è´¥: {}", e))),
        }
    }
    
    // æŒä¹…åŒ–æ–¹æ³•å®ç°
    async fn save(&self, user: &User) -> Result<()> {
        let query = "
            UPDATE users 
            SET name = $2, email = $3, phone = $4, pwd = $5, updated_at = $6, role_id = $7
            WHERE id = $1
        ";
        
        sqlx::query(query)
            .bind(user.id())
            .bind(user.name())
            .bind(user.email())
            .bind(user.phone())
            .bind(user.pwd())
            .bind(user.updated_at())
            .bind(user.role_id())
            .execute(&self.pool)
            .await
            .map_err(|e| DomainError::Infrastructure(format!("ç”¨æˆ·æ›´æ–°å¤±è´¥: {}", e)))?;
        
        Ok(())
    }
}
```

### 2.5 å·¥å…·åº“å…³é”®æ–¹æ³•

#### JWTå·¥å…·åº“æ–¹æ³•
```rust
// æ–‡ä»¶: src/utils/jwt.rs
// JWTå·¥å…·åº“æ ¸å¿ƒæ–¹æ³•

impl JwtUtils {
    // é…ç½®åˆå§‹åŒ–æ–¹æ³•
    pub fn init(config: JwtConfig) -> Result<()> {
        JWT_CONFIG.set(config)
            .map_err(|_| DomainError::Infrastructure("JWTé…ç½®å·²åˆå§‹åŒ–".to_string()))?;
        Ok(())
    }
    
    // å¿«é€Ÿåˆå§‹åŒ–æ–¹æ³•
    pub fn quick_init() -> Result<()> {
        let config = JwtConfig {
            secret: "your-secret-key-for-jwt-token-generation".to_string(),
            expiry_hours: 24,
        };
        Self::init(config)
    }
    
    // ä»¤ç‰Œç”Ÿæˆæ–¹æ³•
    pub fn generate_token(user: &User) -> Result<String> {
        let config = Self::get_config()?;
        let now = Utc::now();
        let exp = now + Duration::hours(config.expiry_hours);
        
        let claims = Claims {
            sub: user.uid().to_string(),
            phone: user.phone().to_string(),
            email: user.email().to_string(),
            exp: exp.timestamp(),
            iat: now.timestamp(),
        };
        
        encode(
            &Header::default(),
            &claims,
            &EncodingKey::from_secret(config.secret.as_ref())
        )
        .map_err(|e| DomainError::Infrastructure(format!("JWTç”Ÿæˆå¤±è´¥: {}", e)))
    }
    
    // ä»¤ç‰ŒéªŒè¯æ–¹æ³•
    pub fn verify_token(token: &str) -> Result<Claims> {
        let config = Self::get_config()?;
        
        decode::<Claims>(
            token,
            &DecodingKey::from_secret(config.secret.as_ref()),
            &Validation::default()
        )
        .map(|token_data| token_data.claims)
        .map_err(|e| DomainError::Authentication(format!("JWTéªŒè¯å¤±è´¥: {}", e)))
    }
}
```

#### é€šç”¨å·¥å…·åº“æ–¹æ³•
```rust
// æ–‡ä»¶: src/utils/tool.rs
// é€šç”¨å·¥å…·åº“æ ¸å¿ƒæ–¹æ³•

impl ToolUtils {
    // å¯†ç å“ˆå¸Œæ–¹æ³•
    pub fn hash_password(password: &str) -> Result<String> {
        hash(password, DEFAULT_COST)
            .map_err(|e| DomainError::Infrastructure(format!("å¯†ç å“ˆå¸Œå¤±è´¥: {}", e)))
    }
    
    // å¯†ç éªŒè¯æ–¹æ³•
    pub fn verify_password(password: &str, hash: &str) -> Result<bool> {
        verify(password, hash)
            .map_err(|e| DomainError::Infrastructure(format!("å¯†ç éªŒè¯å¤±è´¥: {}", e)))
    }
}
```

### 2.6 ä¸­é—´ä»¶å…³é”®æ–¹æ³•

#### JWTè®¤è¯ä¸­é—´ä»¶
```rust
// æ–‡ä»¶: src/presentation/http/middleware.rs
// JWTè®¤è¯ä¸­é—´ä»¶å®ç°

pub async fn jwt_auth_middleware(
    request: Request<Body>,
    next: Next,
) -> Result<Response, (StatusCode, Json<Value>)> {
    let path = request.uri().path();
    
    // ç™½åå•æœºåˆ¶
    let whitelist_paths = vec![
        "/api/auth/login",
        "/api/auth/register", 
        "/health",
    ];
    
    // ç™½åå•æ£€æŸ¥
    if whitelist_paths.iter().any(|&whitelist_path| path == whitelist_path) {
        Logger::info(format!("ğŸ”“ [JWTä¸­é—´ä»¶] ç™½åå•è·¯å¾„è·³è¿‡è®¤è¯: {}", path));
        return Ok(next.run(request).await);
    }
    
    // JWTéªŒè¯é€»è¾‘
    let auth_header = request
        .headers()
        .get(header::AUTHORIZATION)
        .and_then(|header| header.to_str().ok());
    
    if let Some(auth_header) = auth_header {
        if auth_header.starts_with("Bearer ") {
            let token = &auth_header[7..];
            
            // è°ƒç”¨JWTå·¥å…·åº“éªŒè¯
            match JwtUtils::verify_token(token) {
                Ok(claims) => {
                    Logger::info(format!("ğŸ” [JWTä¸­é—´ä»¶] TokenéªŒè¯æˆåŠŸ: {}", claims.sub));
                    Ok(next.run(request).await)
                },
                Err(e) => {
                    Logger::warn(format!("âš ï¸ [JWTä¸­é—´ä»¶] TokenéªŒè¯å¤±è´¥: {}", e));
                    Err(create_error_response(
                        StatusCode::UNAUTHORIZED,
                        "INVALID_TOKEN",
                        "æ— æ•ˆçš„JWTä»¤ç‰Œ",
                    ))
                }
            }
        } else {
            Err(create_error_response(
                StatusCode::UNAUTHORIZED,
                "INVALID_AUTH_HEADER",
                "Authorizationå¤´æ ¼å¼é”™è¯¯",
            ))
        }
    } else {
        Err(create_error_response(
            StatusCode::UNAUTHORIZED,
            "MISSING_AUTH_TOKEN",
            "ç¼ºå°‘Authorizationå¤´",
        ))
    }
}
```

## 3. å¼€å‘æ¨¡å¼å’Œæœ€ä½³å®è·µ

### 3.1 é”™è¯¯å¤„ç†æ¨¡å¼

#### ç»Ÿä¸€é”™è¯¯ç±»å‹
```rust
// æ–‡ä»¶: src/domain/errors.rs
// é¢†åŸŸé”™è¯¯å®šä¹‰

pub enum DomainError {
    Authentication(String),    // è®¤è¯é”™è¯¯
    Validation(String),        // éªŒè¯é”™è¯¯
    Infrastructure(String),    // åŸºç¡€è®¾æ–½é”™è¯¯
    NotFound(String),          // æœªæ‰¾åˆ°é”™è¯¯
}

// é”™è¯¯è½¬æ¢å®ç°
impl From<sqlx::Error> for DomainError {
    fn from(err: sqlx::Error) -> Self {
        DomainError::Infrastructure(format!("æ•°æ®åº“é”™è¯¯: {}", err))
    }
}
```

#### é”™è¯¯å¤„ç†æ–¹æ³•
```rust
// é“¾å¼é”™è¯¯å¤„ç†
let result = some_operation()
    .map_err(|e| DomainError::Infrastructure(format!("æ“ä½œå¤±è´¥: {}", e)))?;

// ä¸Šä¸‹æ–‡é”™è¯¯å¤„ç†
match user_repository.find_by_phone(phone).await {
    Ok(Some(user)) => Ok(user),
    Ok(None) => Err(DomainError::NotFound("ç”¨æˆ·æœªæ‰¾åˆ°".to_string())),
    Err(e) => Err(DomainError::Infrastructure(format!("æŸ¥è¯¢å¤±è´¥: {}", e))),
}
```

### 3.2 æ—¥å¿—è®°å½•æ¨¡å¼

#### ç»“æ„åŒ–æ—¥å¿—æ–¹æ³•
```rust
// ä¸šåŠ¡æµç¨‹æ—¥å¿—
Logger::info(&format!("ğŸ” [{}] {}", "ç”¨æˆ·ç™»å½•", "å¼€å§‹ç™»å½•æµç¨‹"));
Logger::info(&format!("âœ… [{}] {}", "ç”¨æˆ·ç™»å½•", "ç™»å½•æˆåŠŸ"));
Logger::warn(&format!("âŒ [{}] {}", "ç”¨æˆ·ç™»å½•", "ç™»å½•å¤±è´¥"));

// è¯¦ç»†çŠ¶æ€æ—¥å¿—
Logger::info(&format!("ğŸ” [{}] å¼€å§‹éªŒè¯ç”¨æˆ· {} çš„å¯†ç ", "å¯†ç éªŒè¯", user.uid()));
Logger::info(&format!("ğŸ” [{}] éªŒè¯ç»“æœ: {}", "å¯†ç éªŒè¯", is_valid));

// æ€§èƒ½ç›‘æ§æ—¥å¿—
let start_time = Instant::now();
// ... ä¸šåŠ¡é€»è¾‘
let duration = start_time.elapsed();
Logger::info(&format!("â±ï¸ [{}] å¤„ç†æ—¶é—´: {}ms", "ç™»å½•æµç¨‹", duration.as_millis()));
```

### 3.3 ä¾èµ–æ³¨å…¥æ¨¡å¼

#### æ„é€ å‡½æ•°æ³¨å…¥
```rust
// ç”¨ä¾‹å±‚ä¾èµ–æ³¨å…¥
pub struct LoginUserUseCase {
    user_repository: Arc<dyn UserRepository>,  // æ¥å£ä¾èµ–
}

impl LoginUserUseCase {
    pub fn new(user_repository: Arc<dyn UserRepository>) -> Self {
        Self { user_repository }
    }
}

// æ§åˆ¶å™¨å±‚ä¾èµ–æ³¨å…¥
pub struct AuthController {
    login_use_case: Arc<LoginUserUseCase>,     // ç”¨ä¾‹ä¾èµ–
}

impl AuthController {
    pub fn new(login_use_case: Arc<LoginUserUseCase>) -> Self {
        Self { login_use_case }
    }
}
```

#### å®¹å™¨é…ç½®
```rust
// æ–‡ä»¶: src/app/dependency_container.rs
// ä¾èµ–å®¹å™¨é…ç½®æ¨¡å¼

impl DependencyContainer {
    pub fn new(pool: PgPool) -> Self {
        // 1. ä»“å‚¨å±‚
        let user_repository: Arc<dyn UserRepository> = 
            Arc::new(PostgresUserRepository::new(pool.clone()));
        
        // 2. ç”¨ä¾‹å±‚
        let login_use_case = Arc::new(LoginUserUseCase::new(
            user_repository.clone(),
        ));
        
        // 3. æ§åˆ¶å™¨å±‚
        let auth_controller = Arc::new(AuthController::new(
            login_use_case.clone()
        ));
        
        // 4. åº”ç”¨çŠ¶æ€
        let app_state = AppState {
            auth_controller,
        };
        
        Self { app_state }
    }
}
```

## 4. æ–°åŠŸèƒ½å¼€å‘æ–¹æ³•

### 4.1 åŸºäºç™»å½•åŠŸèƒ½çš„å¼€å‘æ¨¡æ¿

#### ç¬¬ä¸€æ­¥ï¼šå®šä¹‰é¢†åŸŸå®ä½“
```rust
// 1. åœ¨ src/domain/entities.rs ä¸­å®šä¹‰æ–°å®ä½“
pub struct NewEntity {
    id: Uuid,
    // ... å…¶ä»–å­—æ®µ
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
}

impl NewEntity {
    pub fn new(/* å‚æ•° */) -> Self {
        Self {
            id: Uuid::new_v4(),
            // ... å­—æ®µèµ‹å€¼
            created_at: Utc::now(),
            updated_at: Utc::now(),
        }
    }
    
    pub fn reconstruct(/* æ‰€æœ‰å­—æ®µ */) -> Self {
        Self { /* ç›´æ¥èµ‹å€¼ */ }
    }
}
```

#### ç¬¬äºŒæ­¥ï¼šå®šä¹‰ä»“å‚¨æ¥å£
```rust
// 2. åœ¨ src/domain/repositories.rs ä¸­å®šä¹‰ä»“å‚¨æ¥å£
#[async_trait]
pub trait NewEntityRepository: Send + Sync {
    async fn find_by_id(&self, id: &Uuid) -> Result<Option<NewEntity>>;
    async fn save(&self, entity: &NewEntity) -> Result<()>;
    async fn delete(&self, id: &Uuid) -> Result<()>;
}
```

#### ç¬¬ä¸‰æ­¥ï¼šå®ç°ç”¨ä¾‹
```rust
// 3. åœ¨ src/application/use_cases/ ä¸­å®ç°ç”¨ä¾‹
pub struct CreateNewEntityUseCase {
    repository: Arc<dyn NewEntityRepository>,
}

impl CreateNewEntityUseCase {
    pub fn new(repository: Arc<dyn NewEntityRepository>) -> Self {
        Self { repository }
    }
    
    pub async fn execute(&self, command: CreateCommand) -> Result<CreateResponse> {
        // 1. éªŒè¯è¾“å…¥
        self.validate_command(&command)?;
        
        // 2. åˆ›å»ºå®ä½“
        let entity = NewEntity::new(/* å‚æ•° */);
        
        // 3. æŒä¹…åŒ–
        self.repository.save(&entity).await?;
        
        // 4. è¿”å›å“åº”
        Ok(CreateResponse { /* å­—æ®µæ˜ å°„ */ })
    }
}
```

#### ç¬¬å››æ­¥ï¼šå®ç°æ§åˆ¶å™¨
```rust
// 4. åœ¨ src/presentation/http/ ä¸­å®ç°æ§åˆ¶å™¨
pub struct NewEntityController {
    create_use_case: Arc<CreateNewEntityUseCase>,
}

impl NewEntityController {
    pub async fn create(&self, request: Value) -> Result<Value> {
        let command: CreateCommand = serde_json::from_value(request)?;
        let response = self.create_use_case.execute(command).await?;
        let response_value = Logger::to_json_value(response)?;
        Ok(response_value)
    }
}
```

#### ç¬¬äº”æ­¥ï¼šé…ç½®è·¯ç”±
```rust
// 5. åœ¨ src/app/routes/ ä¸­é…ç½®è·¯ç”±
pub fn create_new_entity_routes(app_state: AppState) -> Router {
    Router::new()
        .route("/api/new-entity", post(create))
        .with_state(app_state)
}

async fn create(
    State(app_state): State<AppState>,
    Json(request): Json<Value>
) -> Result<Json<Value>, (StatusCode, Json<Value>)> {
    match app_state.new_entity_controller.create(request).await {
        Ok(response) => Ok(Json(response)),
        Err(e) => Err((StatusCode::BAD_REQUEST, Json(json!({"error": e.to_string()}))))
    }
}
```

### 4.2 æµ‹è¯•å¼€å‘æ–¹æ³•

#### å•å…ƒæµ‹è¯•æ¨¡æ¿
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use mockall::predicate::*;
    
    #[tokio::test]
    async fn test_login_success() {
        // 1. å‡†å¤‡æµ‹è¯•æ•°æ®
        let mut mock_repo = MockUserRepository::new();
        mock_repo
            .expect_find_by_phone()
            .with(eq("13800138000"))
            .times(1)
            .returning(|_| Ok(Some(create_test_user())));
        
        // 2. åˆ›å»ºç”¨ä¾‹
        let use_case = LoginUserUseCase::new(Arc::new(mock_repo));
        
        // 3. æ‰§è¡Œæµ‹è¯•
        let command = LoginUserCommand {
            identifier: "13800138000".to_string(),
            password: "correct_password".to_string(),
        };
        
        let result = use_case.execute(command).await;
        
        // 4. éªŒè¯ç»“æœ
        assert!(result.is_ok());
        let response = result.unwrap();
        assert_eq!(response.phone, "13800138000");
    }
}
```

## 5. éƒ¨ç½²å’Œè¿ç»´æ–¹æ³•

### 5.1 ç¯å¢ƒé…ç½®æ–¹æ³•

#### é…ç½®æ–‡ä»¶ç®¡ç†
```toml
# config/production.toml
[database]
url = "${DATABASE_URL}"
max_connections = 20

[server]
host = "0.0.0.0"
port = 8080

[jwt]
secret = "${JWT_SECRET}"
expiry_hours = 24
```

#### ç¯å¢ƒå˜é‡è®¾ç½®
```bash
# è®¾ç½®ç¯å¢ƒå˜é‡
export DATABASE_URL="postgresql://user:password@localhost/prod_db"
export JWT_SECRET="your-production-secret-key"
export RUST_LOG="info"
```

### 5.2 ç›‘æ§å’Œæ—¥å¿—æ–¹æ³•

#### å¥åº·æ£€æŸ¥ç«¯ç‚¹
```rust
// æ–‡ä»¶: src/app/routes/main_routes.rs
async fn health_check() -> Json<Value> {
    Json(json!({
        "status": "OK",
        "timestamp": Utc::now(),
        "version": env!("CARGO_PKG_VERSION"),
        "service": "qiqimanyou_server"
    }))
}
```

#### æ€§èƒ½ç›‘æ§
```rust
// è¯·æ±‚æ€§èƒ½ç›‘æ§
let start_time = Instant::now();
let result = business_logic().await;
let duration = start_time.elapsed();

Logger::info(&format!("â±ï¸ [æ€§èƒ½ç›‘æ§] {} å¤„ç†æ—¶é—´: {}ms", 
    "ä¸šåŠ¡æ“ä½œ", duration.as_millis()));
```

## 6. æ€»ç»“

### 6.1 æ ¸å¿ƒå¼€å‘åŸåˆ™

1. **åˆ†å±‚æ¸…æ™°**: ä¸¥æ ¼æŒ‰ç…§DDDåˆ†å±‚æ¶æ„ç»„ç»‡ä»£ç 
2. **ä¾èµ–å€’ç½®**: é«˜å±‚æ¨¡å—ä¸ä¾èµ–ä½å±‚æ¨¡å—ï¼Œéƒ½ä¾èµ–æŠ½è±¡
3. **å•ä¸€èŒè´£**: æ¯ä¸ªç±»å’Œæ–¹æ³•åªè´Ÿè´£ä¸€ä¸ªèŒè´£
4. **é”™è¯¯å¤„ç†**: ç»Ÿä¸€çš„é”™è¯¯ç±»å‹å’Œå¤„ç†æœºåˆ¶
5. **æ—¥å¿—è®°å½•**: ç»“æ„åŒ–æ—¥å¿—ï¼Œä¾¿äºè°ƒè¯•å’Œç›‘æ§

### 6.2 å…³é”®æ–¹æ³•å¼•ç”¨æ€»ç»“

| å±‚æ¬¡ | å…³é”®æ–¹æ³• | æ–‡ä»¶ä½ç½® | ä¸»è¦åŠŸèƒ½ |
|-----|---------|---------|---------|
| é¢†åŸŸå±‚ | `User::new()` | `src/domain/entities.rs` | åˆ›å»ºæ–°å®ä½“ |
| é¢†åŸŸå±‚ | `User::reconstruct()` | `src/domain/entities.rs` | ä»æ•°æ®åº“é‡æ„ |
| ç”¨ä¾‹å±‚ | `LoginUserUseCase::execute()` | `src/application/use_cases/auth/login_user.rs` | ä¸šåŠ¡æµç¨‹ç¼–æ’ |
| æ§åˆ¶å™¨å±‚ | `AuthController::login()` | `src/presentation/http/auth_controller.rs` | HTTPè¯·æ±‚å¤„ç† |
| ä»“å‚¨å±‚ | `PostgresUserRepository::find_by_phone()` | `src/infrastructure/persistence/postgres_user_repository.rs` | æ•°æ®æŸ¥è¯¢ |
| å·¥å…·å±‚ | `JwtUtils::generate_token()` | `src/utils/jwt.rs` | JWTç”Ÿæˆ |
| å·¥å…·å±‚ | `ToolUtils::verify_password()` | `src/utils/tool.rs` | å¯†ç éªŒè¯ |
| ä¸­é—´ä»¶å±‚ | `jwt_auth_middleware()` | `src/presentation/http/middleware.rs` | JWTè®¤è¯ |

### 6.3 å¼€å‘æ•ˆç‡æå‡

é€šè¿‡éµå¾ªè¿™å¥—å¼€å‘æ–¹æ³•ï¼Œå¯ä»¥æ˜¾è‘—æå‡å¼€å‘æ•ˆç‡ï¼š

- ğŸš€ **å¿«é€Ÿå¼€å‘**: æ ‡å‡†åŒ–çš„å¼€å‘æ¨¡æ¿
- ğŸ›¡ï¸ **è´¨é‡ä¿è¯**: ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
- ğŸ”§ **æ˜“äºç»´æŠ¤**: æ¸…æ™°çš„åˆ†å±‚æ¶æ„å’ŒèŒè´£åˆ’åˆ†
- ğŸ“ˆ **å¯æ‰©å±•æ€§**: åŸºäºæ¥å£çš„ä¾èµ–æ³¨å…¥
- ğŸ§ª **å¯æµ‹è¯•æ€§**: Mockå‹å¥½çš„è®¾è®¡æ¨¡å¼

è¿™å¥—æ–¹æ³•ç»è¿‡ç™»å½•åŠŸèƒ½çš„å®é™…éªŒè¯ï¼Œå¯ä»¥ä½œä¸ºåç»­åŠŸèƒ½å¼€å‘çš„æ ‡å‡†å‚è€ƒã€‚
