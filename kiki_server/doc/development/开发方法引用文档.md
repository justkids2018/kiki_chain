# 开发方法引用文档

## 1. 开发流程指南

### 1.1 基于登录功能的开发方法论

本文档基于已实现的登录功能，总结出一套可复用的开发方法和关键方法引用。

### 1.2 DDD开发步骤

```
1. 领域建模 → 2. 定义仓储接口 → 3. 实现用例 → 4. 创建控制器 → 5. 配置路由 → 6. 集成测试
```

## 2. 关键方法引用清单

### 2.1 领域层关键方法

#### 实体创建方法
```rust
// 文件: src/domain/entities.rs
// 方法: User::new() - 创建新实体
pub fn new(
    uid: String,
    name: String, 
    email: String,
    phone: String,
    pwd: String,
    role_id: i32,
) -> Self {
    Self {
        id: Uuid::new_v4(),
        uid,
        name,
        email,
        phone,
        pwd,
        created_at: Utc::now(),
        updated_at: Utc::now(),
        role_id,
    }
}

// 方法: User::reconstruct() - 从数据库重构实体
pub fn reconstruct(/* 所有字段 */) -> Self

// 方法: User::update_timestamp() - 更新时间戳
pub fn update_timestamp(&mut self) {
    self.updated_at = Utc::now();
}
```

#### 仓储接口定义方法
```rust
// 文件: src/domain/repositories.rs
// 定义仓储接口的标准模式

#[async_trait]
pub trait UserRepository: Send + Sync {
    // 查询方法
    async fn find_by_phone(&self, phone: &str) -> Result<Option<User>>;
    async fn find_by_email(&self, email: &str) -> Result<Option<User>>;
    async fn find_by_id(&self, id: &Uuid) -> Result<Option<User>>;
    
    // 持久化方法
    async fn save(&self, user: &User) -> Result<()>;
    async fn delete(&self, id: &Uuid) -> Result<()>;
}
```

### 2.2 应用层关键方法

#### 用例实现模式
```rust
// 文件: src/application/use_cases/auth/login_user.rs
// 标准用例结构和方法

pub struct LoginUserUseCase {
    user_repository: Arc<dyn UserRepository>,
}

impl LoginUserUseCase {
    // 构造方法 - 依赖注入
    pub fn new(user_repository: Arc<dyn UserRepository>) -> Self {
        Self { user_repository }
    }
    
    // 主执行方法 - 业务流程编排
    pub async fn execute(&self, command: LoginUserCommand) -> Result<LoginUserResponse> {
        // 1. 输入验证
        self.validate_command(&command)?;
        
        // 2. 业务逻辑执行
        let user = self.find_user(&command.identifier).await?;
        self.verify_password(&user, &command.password)?;
        
        // 3. 副作用处理
        let mut updated_user = user.clone();
        updated_user.update_timestamp();
        self.user_repository.save(&updated_user).await?;
        
        // 4. 工具库调用
        let token = JwtUtils::generate_token(&updated_user)?;
        
        // 5. 响应构建
        Ok(LoginUserResponse { /* 字段映射 */ })
    }
    
    // 私有辅助方法 - 输入验证
    fn validate_command(&self, command: &LoginUserCommand) -> Result<()> {
        if command.identifier.trim().is_empty() {
            return Err(DomainError::Validation("手机号或邮箱不能为空".to_string()));
        }
        if command.password.trim().is_empty() {
            return Err(DomainError::Validation("密码不能为空".to_string()));
        }
        Ok(())
    }
    
    // 私有辅助方法 - 业务逻辑
    async fn find_user(&self, identifier: &str) -> Result<User> {
        if let Some(user) = self.user_repository.find_by_phone(identifier).await? {
            return Ok(user);
        }
        Err(DomainError::Authentication("用户名/邮箱或密码错误".to_string()))
    }
    
    // 私有辅助方法 - 密码验证
    fn verify_password(&self, user: &User, password: &str) -> Result<()> {
        Logger::info(&format!("🔍 [密码验证] 开始验证用户 {} 的密码", user.uid()));
        
        let is_valid = ToolUtils::verify_password(password, user.pwd())?;
        Logger::info(&format!("🔍 [密码验证] 验证结果: {}", is_valid));
        
        if !is_valid {
            Logger::warn(&format!("❌ [密码验证] 用户 {} 密码验证失败", user.uid()));
            return Err(DomainError::Authentication("用户名/邮箱或密码错误".to_string()));
        }
        
        Logger::info(&format!("✅ [密码验证] 用户 {} 密码验证成功", user.uid()));
        Ok(())
    }
}
```

#### 命令和响应DTO模式
```rust
// 命令模式 - 输入封装
#[derive(Debug, Deserialize)]
pub struct LoginUserCommand {
    pub identifier: String,  // 业务标识符
    pub password: String,    // 敏感信息
}

// 响应模式 - 输出封装
#[derive(Debug, Serialize)]
pub struct LoginUserResponse {
    pub user_id: String,     // 业务ID
    pub name: String,        // 显示信息
    pub email: String,       // 联系信息
    pub token: String,       // 会话信息
    pub message: String,     // 状态消息
    pub phone: String,       // 联系信息
    pub role_id: i32,        // 权限信息
}
```

### 2.3 表现层关键方法

#### 控制器实现模式
```rust
// 文件: src/presentation/http/auth_controller.rs
// 控制器标准结构和方法

pub struct AuthController {
    register_use_case: Arc<RegisterUserUseCase>,
    login_use_case: Arc<LoginUserUseCase>,
}

impl AuthController {
    // 构造方法 - 用例注入
    pub fn new(
        register_use_case: Arc<RegisterUserUseCase>,
        login_use_case: Arc<LoginUserUseCase>,
    ) -> Self {
        Self {
            register_use_case,
            login_use_case,
        }
    }
    
    // HTTP处理方法 - JSON转换
    pub async fn login(&self, request: Value) -> Result<Value> {
        // 1. 请求反序列化
        let command: LoginUserCommand = serde_json::from_value(request)
            .map_err(|e| DomainError::Validation(format!("请求参数解析失败: {}", e)))?;
        
        // 2. 用例调用
        let response = self.login_use_case.execute(command).await?;
        
        // 3. 响应序列化
        let response_value = Logger::to_json_value(response)
            .map_err(|e| DomainError::Infrastructure(format!("响应序列化失败: {}", e)))?;
        
        Ok(response_value)
    }
}
```

#### 路由配置方法
```rust
// 文件: src/app/routes/auth.rs
// 路由配置标准模式

pub fn create_auth_routes(app_state: AppState) -> Router {
    Logger::info("🔐 [认证模块] 初始化认证路由");
    
    Router::new()
        .route("/api/auth/login", post(login))
        .route("/api/auth/register", post(register))
        .route("/api/auth/verify", get(verify))
        .with_state(app_state)
}

// HTTP处理器方法
#[instrument(name = "login")]
async fn login(
    State(app_state): State<AppState>,
    Json(request): Json<Value>
) -> Result<Json<Value>, (StatusCode, Json<Value>)> {
    Logger::info("🔐 [用户登录] 开始登录流程");
    
    match app_state.auth_controller.login(request).await {
        Ok(response) => {
            Logger::info("✅ [用户登录] 登录成功");
            Ok(Json(response))
        },
        Err(e) => {
            Logger::warn(&format!("🚫 [用户登录] 登录失败: {:?}", e));
            Err((StatusCode::UNAUTHORIZED, Json(json!({
                "error": "用户或密码错误"
            }))))
        }
    }
}
```

### 2.4 基础设施层关键方法

#### 仓储实现模式
```rust
// 文件: src/infrastructure/persistence/postgres_user_repository.rs
// PostgreSQL仓储实现标准模式

pub struct PostgresUserRepository {
    pool: PgPool,
}

impl PostgresUserRepository {
    // 构造方法
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl UserRepository for PostgresUserRepository {
    // 查询方法实现
    async fn find_by_phone(&self, phone: &str) -> Result<Option<User>> {
        let query = "
            SELECT id, uid, name, email, phone, pwd, created_at, updated_at, role_id 
            FROM users 
            WHERE phone = $1
        ";
        
        match sqlx::query_as::<_, UserRow>(query)
            .bind(phone)
            .fetch_optional(&self.pool)
            .await
        {
            Ok(Some(row)) => {
                let user = User::reconstruct(
                    row.id, row.uid, row.name, row.email, 
                    row.phone, row.pwd, row.created_at, 
                    row.updated_at, row.role_id,
                );
                Ok(Some(user))
            },
            Ok(None) => Ok(None),
            Err(e) => Err(DomainError::Infrastructure(format!("数据库查询失败: {}", e))),
        }
    }
    
    // 持久化方法实现
    async fn save(&self, user: &User) -> Result<()> {
        let query = "
            UPDATE users 
            SET name = $2, email = $3, phone = $4, pwd = $5, updated_at = $6, role_id = $7
            WHERE id = $1
        ";
        
        sqlx::query(query)
            .bind(user.id())
            .bind(user.name())
            .bind(user.email())
            .bind(user.phone())
            .bind(user.pwd())
            .bind(user.updated_at())
            .bind(user.role_id())
            .execute(&self.pool)
            .await
            .map_err(|e| DomainError::Infrastructure(format!("用户更新失败: {}", e)))?;
        
        Ok(())
    }
}
```

### 2.5 工具库关键方法

#### JWT工具库方法
```rust
// 文件: src/utils/jwt.rs
// JWT工具库核心方法

impl JwtUtils {
    // 配置初始化方法
    pub fn init(config: JwtConfig) -> Result<()> {
        JWT_CONFIG.set(config)
            .map_err(|_| DomainError::Infrastructure("JWT配置已初始化".to_string()))?;
        Ok(())
    }
    
    // 快速初始化方法
    pub fn quick_init() -> Result<()> {
        let config = JwtConfig {
            secret: "your-secret-key-for-jwt-token-generation".to_string(),
            expiry_hours: 24,
        };
        Self::init(config)
    }
    
    // 令牌生成方法
    pub fn generate_token(user: &User) -> Result<String> {
        let config = Self::get_config()?;
        let now = Utc::now();
        let exp = now + Duration::hours(config.expiry_hours);
        
        let claims = Claims {
            sub: user.uid().to_string(),
            phone: user.phone().to_string(),
            email: user.email().to_string(),
            exp: exp.timestamp(),
            iat: now.timestamp(),
        };
        
        encode(
            &Header::default(),
            &claims,
            &EncodingKey::from_secret(config.secret.as_ref())
        )
        .map_err(|e| DomainError::Infrastructure(format!("JWT生成失败: {}", e)))
    }
    
    // 令牌验证方法
    pub fn verify_token(token: &str) -> Result<Claims> {
        let config = Self::get_config()?;
        
        decode::<Claims>(
            token,
            &DecodingKey::from_secret(config.secret.as_ref()),
            &Validation::default()
        )
        .map(|token_data| token_data.claims)
        .map_err(|e| DomainError::Authentication(format!("JWT验证失败: {}", e)))
    }
}
```

#### 通用工具库方法
```rust
// 文件: src/utils/tool.rs
// 通用工具库核心方法

impl ToolUtils {
    // 密码哈希方法
    pub fn hash_password(password: &str) -> Result<String> {
        hash(password, DEFAULT_COST)
            .map_err(|e| DomainError::Infrastructure(format!("密码哈希失败: {}", e)))
    }
    
    // 密码验证方法
    pub fn verify_password(password: &str, hash: &str) -> Result<bool> {
        verify(password, hash)
            .map_err(|e| DomainError::Infrastructure(format!("密码验证失败: {}", e)))
    }
}
```

### 2.6 中间件关键方法

#### JWT认证中间件
```rust
// 文件: src/presentation/http/middleware.rs
// JWT认证中间件实现

pub async fn jwt_auth_middleware(
    request: Request<Body>,
    next: Next,
) -> Result<Response, (StatusCode, Json<Value>)> {
    let path = request.uri().path();
    
    // 白名单机制
    let whitelist_paths = vec![
        "/api/auth/login",
        "/api/auth/register", 
        "/health",
    ];
    
    // 白名单检查
    if whitelist_paths.iter().any(|&whitelist_path| path == whitelist_path) {
        Logger::info(format!("🔓 [JWT中间件] 白名单路径跳过认证: {}", path));
        return Ok(next.run(request).await);
    }
    
    // JWT验证逻辑
    let auth_header = request
        .headers()
        .get(header::AUTHORIZATION)
        .and_then(|header| header.to_str().ok());
    
    if let Some(auth_header) = auth_header {
        if auth_header.starts_with("Bearer ") {
            let token = &auth_header[7..];
            
            // 调用JWT工具库验证
            match JwtUtils::verify_token(token) {
                Ok(claims) => {
                    Logger::info(format!("🔐 [JWT中间件] Token验证成功: {}", claims.sub));
                    Ok(next.run(request).await)
                },
                Err(e) => {
                    Logger::warn(format!("⚠️ [JWT中间件] Token验证失败: {}", e));
                    Err(create_error_response(
                        StatusCode::UNAUTHORIZED,
                        "INVALID_TOKEN",
                        "无效的JWT令牌",
                    ))
                }
            }
        } else {
            Err(create_error_response(
                StatusCode::UNAUTHORIZED,
                "INVALID_AUTH_HEADER",
                "Authorization头格式错误",
            ))
        }
    } else {
        Err(create_error_response(
            StatusCode::UNAUTHORIZED,
            "MISSING_AUTH_TOKEN",
            "缺少Authorization头",
        ))
    }
}
```

## 3. 开发模式和最佳实践

### 3.1 错误处理模式

#### 统一错误类型
```rust
// 文件: src/domain/errors.rs
// 领域错误定义

pub enum DomainError {
    Authentication(String),    // 认证错误
    Validation(String),        // 验证错误
    Infrastructure(String),    // 基础设施错误
    NotFound(String),          // 未找到错误
}

// 错误转换实现
impl From<sqlx::Error> for DomainError {
    fn from(err: sqlx::Error) -> Self {
        DomainError::Infrastructure(format!("数据库错误: {}", err))
    }
}
```

#### 错误处理方法
```rust
// 链式错误处理
let result = some_operation()
    .map_err(|e| DomainError::Infrastructure(format!("操作失败: {}", e)))?;

// 上下文错误处理
match user_repository.find_by_phone(phone).await {
    Ok(Some(user)) => Ok(user),
    Ok(None) => Err(DomainError::NotFound("用户未找到".to_string())),
    Err(e) => Err(DomainError::Infrastructure(format!("查询失败: {}", e))),
}
```

### 3.2 日志记录模式

#### 结构化日志方法
```rust
// 业务流程日志
Logger::info(&format!("🔐 [{}] {}", "用户登录", "开始登录流程"));
Logger::info(&format!("✅ [{}] {}", "用户登录", "登录成功"));
Logger::warn(&format!("❌ [{}] {}", "用户登录", "登录失败"));

// 详细状态日志
Logger::info(&format!("🔍 [{}] 开始验证用户 {} 的密码", "密码验证", user.uid()));
Logger::info(&format!("🔍 [{}] 验证结果: {}", "密码验证", is_valid));

// 性能监控日志
let start_time = Instant::now();
// ... 业务逻辑
let duration = start_time.elapsed();
Logger::info(&format!("⏱️ [{}] 处理时间: {}ms", "登录流程", duration.as_millis()));
```

### 3.3 依赖注入模式

#### 构造函数注入
```rust
// 用例层依赖注入
pub struct LoginUserUseCase {
    user_repository: Arc<dyn UserRepository>,  // 接口依赖
}

impl LoginUserUseCase {
    pub fn new(user_repository: Arc<dyn UserRepository>) -> Self {
        Self { user_repository }
    }
}

// 控制器层依赖注入
pub struct AuthController {
    login_use_case: Arc<LoginUserUseCase>,     // 用例依赖
}

impl AuthController {
    pub fn new(login_use_case: Arc<LoginUserUseCase>) -> Self {
        Self { login_use_case }
    }
}
```

#### 容器配置
```rust
// 文件: src/app/dependency_container.rs
// 依赖容器配置模式

impl DependencyContainer {
    pub fn new(pool: PgPool) -> Self {
        // 1. 仓储层
        let user_repository: Arc<dyn UserRepository> = 
            Arc::new(PostgresUserRepository::new(pool.clone()));
        
        // 2. 用例层
        let login_use_case = Arc::new(LoginUserUseCase::new(
            user_repository.clone(),
        ));
        
        // 3. 控制器层
        let auth_controller = Arc::new(AuthController::new(
            login_use_case.clone()
        ));
        
        // 4. 应用状态
        let app_state = AppState {
            auth_controller,
        };
        
        Self { app_state }
    }
}
```

## 4. 新功能开发方法

### 4.1 基于登录功能的开发模板

#### 第一步：定义领域实体
```rust
// 1. 在 src/domain/entities.rs 中定义新实体
pub struct NewEntity {
    id: Uuid,
    // ... 其他字段
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
}

impl NewEntity {
    pub fn new(/* 参数 */) -> Self {
        Self {
            id: Uuid::new_v4(),
            // ... 字段赋值
            created_at: Utc::now(),
            updated_at: Utc::now(),
        }
    }
    
    pub fn reconstruct(/* 所有字段 */) -> Self {
        Self { /* 直接赋值 */ }
    }
}
```

#### 第二步：定义仓储接口
```rust
// 2. 在 src/domain/repositories.rs 中定义仓储接口
#[async_trait]
pub trait NewEntityRepository: Send + Sync {
    async fn find_by_id(&self, id: &Uuid) -> Result<Option<NewEntity>>;
    async fn save(&self, entity: &NewEntity) -> Result<()>;
    async fn delete(&self, id: &Uuid) -> Result<()>;
}
```

#### 第三步：实现用例
```rust
// 3. 在 src/application/use_cases/ 中实现用例
pub struct CreateNewEntityUseCase {
    repository: Arc<dyn NewEntityRepository>,
}

impl CreateNewEntityUseCase {
    pub fn new(repository: Arc<dyn NewEntityRepository>) -> Self {
        Self { repository }
    }
    
    pub async fn execute(&self, command: CreateCommand) -> Result<CreateResponse> {
        // 1. 验证输入
        self.validate_command(&command)?;
        
        // 2. 创建实体
        let entity = NewEntity::new(/* 参数 */);
        
        // 3. 持久化
        self.repository.save(&entity).await?;
        
        // 4. 返回响应
        Ok(CreateResponse { /* 字段映射 */ })
    }
}
```

#### 第四步：实现控制器
```rust
// 4. 在 src/presentation/http/ 中实现控制器
pub struct NewEntityController {
    create_use_case: Arc<CreateNewEntityUseCase>,
}

impl NewEntityController {
    pub async fn create(&self, request: Value) -> Result<Value> {
        let command: CreateCommand = serde_json::from_value(request)?;
        let response = self.create_use_case.execute(command).await?;
        let response_value = Logger::to_json_value(response)?;
        Ok(response_value)
    }
}
```

#### 第五步：配置路由
```rust
// 5. 在 src/app/routes/ 中配置路由
pub fn create_new_entity_routes(app_state: AppState) -> Router {
    Router::new()
        .route("/api/new-entity", post(create))
        .with_state(app_state)
}

async fn create(
    State(app_state): State<AppState>,
    Json(request): Json<Value>
) -> Result<Json<Value>, (StatusCode, Json<Value>)> {
    match app_state.new_entity_controller.create(request).await {
        Ok(response) => Ok(Json(response)),
        Err(e) => Err((StatusCode::BAD_REQUEST, Json(json!({"error": e.to_string()}))))
    }
}
```

### 4.2 测试开发方法

#### 单元测试模板
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use mockall::predicate::*;
    
    #[tokio::test]
    async fn test_login_success() {
        // 1. 准备测试数据
        let mut mock_repo = MockUserRepository::new();
        mock_repo
            .expect_find_by_phone()
            .with(eq("13800138000"))
            .times(1)
            .returning(|_| Ok(Some(create_test_user())));
        
        // 2. 创建用例
        let use_case = LoginUserUseCase::new(Arc::new(mock_repo));
        
        // 3. 执行测试
        let command = LoginUserCommand {
            identifier: "13800138000".to_string(),
            password: "correct_password".to_string(),
        };
        
        let result = use_case.execute(command).await;
        
        // 4. 验证结果
        assert!(result.is_ok());
        let response = result.unwrap();
        assert_eq!(response.phone, "13800138000");
    }
}
```

## 5. 部署和运维方法

### 5.1 环境配置方法

#### 配置文件管理
```toml
# config/production.toml
[database]
url = "${DATABASE_URL}"
max_connections = 20

[server]
host = "0.0.0.0"
port = 8080

[jwt]
secret = "${JWT_SECRET}"
expiry_hours = 24
```

#### 环境变量设置
```bash
# 设置环境变量
export DATABASE_URL="postgresql://user:password@localhost/prod_db"
export JWT_SECRET="your-production-secret-key"
export RUST_LOG="info"
```

### 5.2 监控和日志方法

#### 健康检查端点
```rust
// 文件: src/app/routes/main_routes.rs
async fn health_check() -> Json<Value> {
    Json(json!({
        "status": "OK",
        "timestamp": Utc::now(),
        "version": env!("CARGO_PKG_VERSION"),
        "service": "qiqimanyou_server"
    }))
}
```

#### 性能监控
```rust
// 请求性能监控
let start_time = Instant::now();
let result = business_logic().await;
let duration = start_time.elapsed();

Logger::info(&format!("⏱️ [性能监控] {} 处理时间: {}ms", 
    "业务操作", duration.as_millis()));
```

## 6. 总结

### 6.1 核心开发原则

1. **分层清晰**: 严格按照DDD分层架构组织代码
2. **依赖倒置**: 高层模块不依赖低层模块，都依赖抽象
3. **单一职责**: 每个类和方法只负责一个职责
4. **错误处理**: 统一的错误类型和处理机制
5. **日志记录**: 结构化日志，便于调试和监控

### 6.2 关键方法引用总结

| 层次 | 关键方法 | 文件位置 | 主要功能 |
|-----|---------|---------|---------|
| 领域层 | `User::new()` | `src/domain/entities.rs` | 创建新实体 |
| 领域层 | `User::reconstruct()` | `src/domain/entities.rs` | 从数据库重构 |
| 用例层 | `LoginUserUseCase::execute()` | `src/application/use_cases/auth/login_user.rs` | 业务流程编排 |
| 控制器层 | `AuthController::login()` | `src/presentation/http/auth_controller.rs` | HTTP请求处理 |
| 仓储层 | `PostgresUserRepository::find_by_phone()` | `src/infrastructure/persistence/postgres_user_repository.rs` | 数据查询 |
| 工具层 | `JwtUtils::generate_token()` | `src/utils/jwt.rs` | JWT生成 |
| 工具层 | `ToolUtils::verify_password()` | `src/utils/tool.rs` | 密码验证 |
| 中间件层 | `jwt_auth_middleware()` | `src/presentation/http/middleware.rs` | JWT认证 |

### 6.3 开发效率提升

通过遵循这套开发方法，可以显著提升开发效率：

- 🚀 **快速开发**: 标准化的开发模板
- 🛡️ **质量保证**: 统一的错误处理和日志记录
- 🔧 **易于维护**: 清晰的分层架构和职责划分
- 📈 **可扩展性**: 基于接口的依赖注入
- 🧪 **可测试性**: Mock友好的设计模式

这套方法经过登录功能的实际验证，可以作为后续功能开发的标准参考。
