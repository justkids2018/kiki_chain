# 新功能开发指南（基于登录功能逐步映射）

目的：
- 提供一份可被AI或开发者直接按照步骤执行的新功能开发指南。
- 按照登录业务的实现细节，把每一步的文件、目录、代码逻辑、接口调用、校验与测试点列清楚，确保新功能在 DDD 架构与团队规范下可快速落地。

前提约束（必须遵守）
- 业务逻辑遵循 DDD 架构。
- API 请求必须统一使用 `RequestManager`。
- UI 层的 Controller 必须使用 GetX，并放在当前模块目录下单独的 `controllers/` 目录。
- 所有实体对象放在 `data/domain/entities/`。
- 新功能的 Repository 放在 `data/repositories/`。
- 所有请求路径统一在 `ApiEndpoints` 中定义并引用。
- 全局颜色在 `AppColors` 中管理。
- 路由初始化在 `AppRoutes` 中，路由 path 在 `AppConstants`。

文档结构：
1. 需求到实现的映射（以登录为模板）
2. 目录与文件清单（骨架）
3. 逐步代码逻辑提示（每一步都可生成代码）
4. 接口与 API 示例（RequestManager 使用示例）
5. 校验/边界情况
6. 单元/集成测试建议
7. PR 检查清单
8. 示例：从零到一实现“重置密码”功能（演示如何复用登录模板）

---

## 1. 需求到实现的映射（以登录为模板）

登录功能拆解（每一步都应映射到相应文件与职责）：
1. UI 层：`presentation/pages/login_page.dart`（表单、错误展示、loading 状态、导航）
2. Controller：`presentation/controllers/auth_controller.dart`（表单校验、本地状态、调用 Repository）
3. Repository：`data/repositories/auth_repository.dart`（封装 RequestManager 调用，返回实体/错误）
4. Entity：`data/domain/entities/user.dart`（用户实体定义）
5. API 定义：`lib/config/api_endpoints.dart`（定义登录 path）
6. RequestManager：统一发送请求，处理 token、错误转换、网络重试策略
7. 路由：`lib/app_routes.dart` + `lib/app_constants.dart`（添加登录页面路由）
8. 全局样式：使用 `AppColors` 中定义的颜色

每一个新功能应复制以上责任边界，并替换为对应的业务名。

## 2. 目录与文件清单（骨架）

以 `feature_x` 为例，新功能应该创建如下结构：

- lib/
  - presentation/
    - pages/
      - feature_x_page.dart
    - controllers/
      - feature_x_controller.dart
  - data/
    - domain/
      - entities/
        - feature_x_entity.dart
    - repositories/
      - feature_x_repository.dart
  - config/
    - api_endpoints.dart (已存在，新增 path 常量)
  - ...

## 3. 逐步代码逻辑提示（一步一步对应登录实现）

以下每一步给出：目的 -> 文件 -> 核心代码提示（伪代码） -> 返回值/错误处理

步骤 0：准备
- 目的：确认 API path，实体字段，UI 字段。
- 操作：在 `ApiEndpoints` 中新增 `featureX` path；在 `data/domain/entities/` 新建实体草稿。

步骤 1：创建实体
- 文件：`data/domain/entities/feature_x_entity.dart`
- 伪代码：
  class FeatureXEntity {
    final String id;
    final String name;
    // ...fromJson / toJson
  }
- 关注点：字段校验、nullable vs non-nullable

步骤 2：实现 Repository
- 文件：`data/repositories/feature_x_repository.dart`
- 目的：封装 RequestManager 调用，返回 Entity 或抛出自定义异常
- 伪代码：
  class FeatureXRepository {
    final RequestManager _http;
    FeatureXRepository(this._http);

    Future<FeatureXEntity> createFeatureX(CreateFeatureXParams p) async {
      final res = await _http.post(ApiEndpoints.featureXCreate, body: p.toJson());
      if (res.isSuccess) return FeatureXEntity.fromJson(res.data);
      throw ApiException.fromResponse(res);
    }
  }
- 错误处理：统一用 ApiException，包含 code/message/payload

步骤 3：实现 Controller（Getx）
- 文件：`presentation/controllers/feature_x_controller.dart`
- 目的：持有表单状态、loading、错误信息；调用 Repository；路由导航
- 伪代码：
  class FeatureXController extends GetxController {
    final FeatureXRepository repo;
    var isLoading = false.obs;
    var errorMsg = ''.obs;

    final formKey = GlobalKey<FormState>();
    final nameController = TextEditingController();

    FeatureXController(this.repo);

    Future<void> submit() async {
      if (!formKey.currentState!.validate()) return;
      isLoading.value = true;
      try {
        final r = await repo.createFeatureX(CreateFeatureXParams(name: nameController.text));
        // 成功：导航或提示
      } catch (e) {
        errorMsg.value = parseError(e);
      } finally {
        isLoading.value = false;
      }
    }
  }
- 关注点：取消订阅、资源释放（onClose 清理 controllers）

步骤 4：实现 UI Page
- 文件：`presentation/pages/feature_x_page.dart`
- 目的：表单 UI，使用 controller 中的 observable 状态
- 伪代码：
  class FeatureXPage extends StatelessWidget {
    final controller = Get.put(FeatureXController(Get.find()));
    Widget build(...) {
      return Scaffold(
        body: Form(...)
        // TextFormField(controller: controller.nameController,...)
        // Obx显示loading/error
      );
    }
  }
- 关注点：保持与登录页面一致的 UX 结构（按钮样式、表单校验）

步骤 5：路由与常量
- 在 `AppConstants` 中添加 path: `/feature_x`
- 在 `AppRoutes` 初始化中注册该路由指向 `FeatureXPage`

步骤 6：样式与颜色
- 如果需要新颜色，先在 `AppColors` 中添加常量；UI 使用 `AppColors.primary` 而非硬编码色值

步骤 7：单元与集成测试
- Controller：测试 submit 成功/失败，mock Repository 返回
- Repository：对 RequestManager 进行 mock，测试不同响应码的行为
- UI：Widget test 验证表单校验和状态展示

## 4. 接口与 API 示例（RequestManager 使用示例）

- RequestManager 用法示例：

  final res = await RequestManager.post(
    ApiEndpoints.featureXCreate,
    body: params.toJson(),
    headers: {"Authorization": "Bearer $token"},
  );

  if (!res.success) throw ApiException.fromResponse(res);
  return FeatureXEntity.fromJson(res.data);

- 推荐封装策略：
  - 在 Repository 层处理网络到实体的转换。
  - 在 RequestManager 层统一处理 token 刷新与重试策略。

## 5. 校验 / 边界情况

- 输入校验（前端）：必填、长度、格式（手机号/邮箱正则）
- 后端校验错误：解析并在 Controller 中映射到用户友好信息
- 网络异常：退回到通用错误展示并支持重试
- 并发/去抖：提交按钮防重复点击（基于isLoading）
- 超时策略：RequestManager 默认 15s，可在特殊接口覆盖

## 6. 单元/集成测试建议

- Controller 测试：
  - 表单验证失败不应调用 Repository
  - 成功路径应触发导航或状态更新
  - 异常路径应设置 `errorMsg` 并停止 loading

- Repository 测试：
  - 模拟不同的 HTTP 响应码，验证异常包装

- Widget 测试：
  - 表单校验提示
  - 当 `isLoading` 时禁用按钮并显示 loading

## 7. PR 检查清单

- [ ] 是否遵循 DDD 目录约束
- [ ] 是否使用 `RequestManager` 而非直接 http client
- [ ] Controller 是否使用 GetX，并放在模块的 `controllers/`
- [ ] 实体是否放在 `data/domain/entities/`
- [ ] Repository 是否在 `data/repositories/`
- [ ] 所有 API path 是否在 `ApiEndpoints` 中定义
- [ ] 颜色是否来自 `AppColors`
- [ ] 路由是否在 `AppRoutes` 和 `AppConstants` 中注册
- [ ] 是否添加了单元/集成测试
- [ ] 文档是否在 `doc/` 中说明了变更点

## 8. 示例：实现“重置密码”功能（从登录模板复制）

1. ApiEndpoints 中添加：
```dart
static const resetPassword = '/auth/reset-password';
```

2. 实体：`data/domain/entities/reset_password_response.dart`
3. Repository：`data/repositories/auth_repository.dart` 添加方法：
```dart
Future<void> resetPassword(String phoneOrEmail) async {
  final res = await RequestManager.post(ApiEndpoints.resetPassword, body: {"account": phoneOrEmail});
  if (!res.success) throw ApiException.fromResponse(res);
}
```

4. Controller：`presentation/controllers/auth_controller.dart` 添加 `resetPasswordController`、方法 `resetPassword()`，复用表单逻辑和 loading/error 处理
5. Page：`presentation/pages/reset_password_page.dart`，复用 login_page 的样式和结构
6. 路由：`AppConstants` + `AppRoutes` 注册
7. 测试：参考步骤 6

---

完成说明：
- 将该文档作为团队新功能开发的“模板/规范/执行脚本”保存于 `doc/task/新功能开发指南.md`。
- 任何新功能均应根据本指南逐步执行，AI 可根据本指南生成相应的代码骨架与实现。

如需，我可以：
- 把其中的伪代码直接生成到代码文件中（创建实体、Repository、Controller、Page 的骨架）
- 为登录功能生成更详细的校验/错误码映射表
- 为常见场景（分页、文件上传）写单独的实现模板
